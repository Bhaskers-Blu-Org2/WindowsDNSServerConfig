#---------------------------------#
#      environment configuration  #
#---------------------------------#
version: 1.0.{build}.0
environment:
  AppID:
    secure: IJBqnB6WjtDi3ej/zy2D70Ry1AvJOrlZK5BhSoqEdxNENd0CL9qdMJndbi6p+di3
  AppPass:
    secure: b8lT719n/ll0Bp5SloBvzw==
  Tenant:
    secure: J/my7xsOE9jewR0DDhD+EU5jeo5Bp83/nmIK8a8QI0QLoZXStCOtk1vUjVsKylW2
install:
  - git clone https://github.com/Microsoft/WindowsDNSServer.Config
  - git clone https://github.com/PowerShell/DscResource.Tests
  - ps: |
        Import-Module -Name .\DscResource.Tests\TestHelper.psm1 -Force
        Install-PackageProvider -Name NuGet -MinimumVersion 2.8.5.205 -Force | Out-Null
        Install-Module -Name Pester -Repository PSGallery -Force
        Install-Module -Name AzureRM -Repository PSGallery -Force
        
#---------------------------------#
#      build configuration        #
#---------------------------------#

build: false

#---------------------------------#
#      test configuration         #
#---------------------------------#

test_script:
    - ps: |
        # Suppressing tests until configuration test helper is created
        # $testResultsFile = ".\TestsResults.xml"
        # $res = Invoke-Pester -OutputFormat NUnitXml -OutputFile $testResultsFile -PassThru
        # (New-Object 'System.Net.WebClient').UploadFile("https://ci.appveyor.com/api/testresults/nunit/$($env:APPVEYOR_JOB_ID)", (Resolve-Path $testResultsFile))
        # if ($res.FailedCount -gt 0) {
        #     throw "$($res.FailedCount) tests failed."
        # }

#---------------------------------# 
#      deployment configuration   # 
#---------------------------------# 

# scripts to run before deployment 
deploy_script: 
  - ps: |
        # Correct duplicates in AppVeyor environment psmodulepath
        foreach($path in $env:psmodulepath.split(';').ToUpper().ToLower())
        {
          [array]$correctDirFormat += "$path\;"
        }
        $correctDirFormat = $correctDirFormat.replace("\\","\") | ? {$_ -ne '\;'} | Select-Object -Unique
        foreach ($path in $correctDirFormat.split(';'))
        {
          [string]$fixPath += "$path;"
        }
        $env:psmodulepath = $fixpath.replace(';;',';')
        
        # Load module data and create array of objects containing prerequisite details for use later in Azure Automation
        $ModuleData = Import-PowerShellDataFile -Path ".\$env:APPVEYOR_PROJECT_NAME.psd1"
        $AADSCResourceModules = @()
        foreach($RequiredModule in $ModuleData.RequiredModules[0])
        {
            $ModuleReference = New-Object -TypeName PSObject
            # Latest if no version is specified
            if ($RequiredModule.gettype().Name -eq 'String')
            {
              if ($galleryReference = Invoke-RestMethod -Method Get -Uri "https://www.powershellgallery.com/api/v2/FindPackagesById()?id='$RequiredModule'" -ErrorAction Continue)
              {
                $ModuleReference | Add-Member -MemberType NoteProperty -Name 'Name' -Value $RequiredModule
                $ModuleReference | Add-Member -MemberType NoteProperty -Name 'URI' -Value ($galleryReference | ? {$_.Properties.IsLatestVersion.'#text' -eq $true}).content.src
                $AADSCResourceModules += $ModuleReference
              }
              Install-Module -Name $RequiredModule -force
            }

            # Install specific version if specified
            if ($RequiredModule.gettype().Name -eq 'Hashtable')
            {
              if ($galleryReference = Invoke-RestMethod -Method Get -Uri "https://www.powershellgallery.com/api/v2/FindPackagesById()?id='$($RequiredModule.ModuleName)'" -ErrorAction Continue)
              {
                $ModuleReference | Add-Member -MemberType NoteProperty -Name 'Name' -Value $RequiredModule.ModuleName
                $ModuleReference | Add-Member -MemberType NoteProperty -Name 'URI' -Value ($galleryReference | ? {$_.Properties.Version -eq $RequiredModule.ModuleVersion}).content.src
                $AADSCResourceModules += $ModuleReference
              }
              Install-Module -Name $RequiredModule.ModuleName -RequiredVersion $RequiredModule.ModuleVersion -force
            }
        }
                
        # Log in to Azure
        $loc = 'eastus2'
        $creds = New-Object -typename System.Management.Automation.PSCredential -argumentlist $env:AppID, $(convertto-securestring -String $env:AppPass -AsPlainText -Force)
        
        # Suppress request to share usage information
        if (!(Resolve-Path -Path 'C:\Users\appveyor\AppData\Roaming\Windows Azure Powershell\' -ErrorAction SilentlyContinue))
        {
          mkdir 'C:\Users\appveyor\AppData\Roaming\Windows Azure Powershell\' | Out-Null
        }
        Set-Content -Value '{"enableAzureDataCollection":true}' -Path 'C:\Users\appveyor\AppData\Roaming\Windows Azure Powershell\AzureDataCollectionProfile.json' | Out-Null
        
        Add-AzureRmAccount -Credential $creds -ServicePrincipal -TenantId $env:Tenant | Out-Null
        
        # Create Resource Group
        if (!(Get-AzureRmResourceGroup -Name $env:APPVEYOR_PROJECT_NAME -ErrorAction SilentlyContinue))
        {
            New-AzureRmResourceGroup -Name $env:APPVEYOR_PROJECT_NAME -Location $loc | Out-Null
        }
        
        # Create Azure Automation account
        if (!(Get-AzureRMAutomationAccount -ResourceGroupName $env:APPVEYOR_PROJECT_NAME -Name $env:APPVEYOR_PROJECT_ID -ErrorAction SilentlyContinue))
        {
          New-AzureRMAutomationAccount -ResourceGroupName $env:APPVEYOR_PROJECT_NAME -Name $env:APPVEYOR_PROJECT_ID -Location $loc | Out-Null
        }

        # Upload required DSC resources
        $AADSCImportedModules = @()
        foreach($AADSCModuleToUpload in $AADSCResourceModules) {
          $AADSCImportedModules += New-AzureRMAutomationModule -ResourceGroupName $env:APPVEYOR_PROJECT_NAME -AutomationAccountName $env:APPVEYOR_PROJECT_ID -Name $AADSCModuleToUpload.Name -ContentLink $AADSCModuleToUpload.URI
        }

        # Import Configuration module
        if ($ModuleDir = New-Item -Type Directory -Path $env:ProgramFiles\WindowsPowerShell\Modules\$env:APPVEYOR_PROJECT_NAME -force)
        {
          Copy-Item -Path .\$env:APPVEYOR_PROJECT_NAME.psd1 -Destination $ModuleDir -force
          Copy-Item -Path .\$env:APPVEYOR_PROJECT_NAME.psm1 -Destination $ModuleDir -force
        }
        Import-Module -Name $env:APPVEYOR_PROJECT_NAME

        # Discover configurations from module
        $Configurations = Get-Command -module $env:APPVEYOR_PROJECT_NAME -Type Configuration
        
        # Create configuration scripts and import to Azure Automation
        foreach ($confToCompile in $Configurations) {
          
          $confName = $confToCompile.Name
          $confConfigData = Import-PowerShellDataFile ".\ConfigurationData\$confToCompileName.ConfigData.psd1" -ErrorAction SilentlyContinue
          
          # Create working folder
          New-Item -Path C:\DSC -ItemType Directory -ErrorAction SilentlyContinue | Out-Null
          
          # Create one script per configuration with matching name
          if ($Config = (Get-Command $confName).ScriptBlock)
          {
            "Configuration $confName`n{" | Out-File "C:\DSC\$confName.ps1"
            $Config | Out-File "C:\DSC\$confName.ps1" -Append
            "}`n" | Out-File "C:\DSC\$confName.ps1" -Append

            # Import
            $AADSCImport = Import-AzureRmAutomationDscConfiguration -ResourceGroupName $env:APPVEYOR_PROJECT_NAME -AutomationAccountName $env:APPVEYOR_PROJECT_ID -SourcePath "C:\DSC\$confName.ps1" -Published -Force

            # The resource modules must finish the "Creating" stage before the configuration will compile successfully
            foreach ($AADSCImportedModule in $AADSCImportedModules)
            {
              while ((Get-AzureRMAutomationModule -ResourceGroupName $env:APPVEYOR_PROJECT_NAME -AutomationAccountName $env:APPVEYOR_PROJECT_ID -Name $AADSCImportedModule.Name).ProvisioningState -ne 'Succeeded')
              { 
                $DebugMod = Get-AzureRMAutomationModule -ResourceGroupName $env:APPVEYOR_PROJECT_NAME -AutomationAccountName $env:APPVEYOR_PROJECT_ID -Name $AADSCImportedModule.Name
                $ModName = $DebugMod.Name
                $ModState = $DebugMod.ProvisioningState
                Write-Host "DEBUG: THe module $ModName is in state $ModState"
                Start-Sleep -Seconds 5
              }
            }

            # Compile
            $AADSCCompile = Start-AzureRmAutomationDscCompilationJob -ResourceGroupName $env:APPVEYOR_PROJECT_NAME -AutomationAccountName $env:APPVEYOR_PROJECT_ID -ConfigurationName $AADSCImport.Name -ConfigurationData $confConfigData
            
            $AADSCCompile
          }
          else 
          {
            Write-Error 'No configuration was loaded.'
          }
        }
        
        # TODO - handle no configdata through splatting
        # TODO - standardize approach to deploying ARM template from repo handing off config name as param        
        # TODO - MVP is single VM, complete is multiple VM solution
        # TODO - tests from demo_ci
        
        # Start-Sleep 600
        # Remove-AzureRmResourceGroup -Name $env:APPVEYOR_PROJECT_NAME -Force
